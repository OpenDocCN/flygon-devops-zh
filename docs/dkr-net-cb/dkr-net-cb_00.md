# 前言

本书的目的是为您提供关于 Docker 如何实现容器网络的深入知识。无论您是每天都在使用 Docker，还是刚刚开始接触，本书都将向您介绍 Docker 如何使用 Linux 网络原语来为容器进行网络连接。通过大量示例，我们将涵盖从 Linux 网络基础知识到最新的 Docker 网络驱动程序的所有内容。在此过程中，我们还将探讨如何将现有的网络结构和第三方插件集成到 Docker 中。最终目标是让您对 Docker 提供容器网络功能的过程感到舒适。

像许多开源项目一样，Docker 是一个快速发展的软件。在出版时，最新版本的 Docker 是 1.12。我已尽力确保本书中的内容反映了基于这个版本的最新功能和配置。无论版本如何，这些功能中的许多在 Docker 的早期版本中以某种形式存在。因此，尽管在过去几年中 Docker 的网络功能发生了重大变化，但大部分网络功能仍然以相同的方式实现。正是因为这个原因，我相信本书中的大部分内容在未来很长一段时间内仍然具有相关性。

# **本书涵盖的内容**

第一章 *Linux 网络结构*，将重点介绍 Linux 网络原语。诸如接口创建、寻址和一般连接性等主题将被详细讨论。您还将了解与 Linux 主机网络配置相关的常见 Linux 命令行语法和工具。了解这些基本结构将极大地增加您理解 Docker 如何处理容器网络的能力。

第二章 *配置和监控 Docker 网络*，解释了 Docker 处理容器网络的默认方式。这包括 Docker 网络操作的桥接、主机和映射容器模式。我们还将开始探讨 Docker 如何将基于容器的服务映射到外部或外部网络。还将讨论 Docker 网络的 Linux 主机要求以及一些可能被修改的 Docker 服务级参数。

第三章，“用户定义的网络”，开始了我们关于 Docker 用户定义网络的讨论。用户定义网络的出现极大地增加了 Docker 网络的灵活性，为最终用户提供了更多关于容器连接的可能性。我们将讨论创建用户定义网络所需的语法，并展示如何创建用户定义的桥接和覆盖网络的示例。最后，我们将介绍一些在 Docker 中隔离网络段的选项。

第四章，“构建 Docker 网络”，首先深入探讨了 Docker 如何提供容器连接。从一个没有网络接口的容器开始，我们将介绍在网络上使容器通信所需的所有步骤。然后，我们将讨论使用自定义桥接与 Docker 以及与 Docker 一起使用 OVS 的多个用例。

第五章，“容器链接和 Docker DNS”，讨论了容器名称解析的可用选项。这包括默认的名称解析行为以及存在于用户定义网络中的新嵌入式 DNS 服务器功能。您将熟悉确定每种情况下名称服务器分配的过程。

第六章，“保护容器网络”，展示了与容器安全相关的各种功能和策略。您将了解到几种限制容器暴露和连接范围的选项。我们还将讨论实现利用用户定义的覆盖网络的基于容器的负载均衡器的选项。

第七章，“使用 Weave Net”，将是我们首次接触与 Docker 集成的第三方网络解决方案。Weave 提供了多种与 Docker 集成的方法，包括其自己的 CLI 工具以及一个完整的 Docker 驱动程序。还将演示使用 Weave 提供网络隔离的示例。

第八章《使用 Flannel》，*使用 Flannel*，检查了由 CoreOS 团队构建的第三方网络插件。Flannel 是一个有趣的例子，说明了网络插件如何通过更改 Docker 服务级参数来集成到 Docker 中。除了提供覆盖类型的网络外，Flannel 还提供了主机网关后端，允许主机在满足某些要求的情况下直接路由到彼此。

第九章《探索网络功能》，*探索网络功能*，侧重于新的网络功能如何集成到 Docker 中。我们将研究如何通过评估不同版本的 Docker 引擎来获得对这些新功能的访问和测试。在本章的过程中，我们还将研究现在集成的 MacVLAN 网络驱动程序以及仍在测试中的 IPVLAN 网络驱动程序。

第十章《利用 IPv6》，*利用 IPv6*，涵盖了 IPv6 及 Docker 对其的支持。IPv6 是一个重要的话题，考虑到 IPv4 的当前状态，它值得引起大量关注。在本章中，我们将回顾在 Linux 系统上使用 IPv6 的一些基础知识。然后，我们将花一些时间审查 Docker 如何支持 IPv6，并讨论您在部署周围的一些选项。

第十一章《故障排除 Docker 网络》，*故障排除 Docker 网络*，探讨了在故障排除 Docker 网络时可能采取的一些常见步骤。重点将放在验证配置上，但您还将学习一些可以证明配置是否按预期工作的步骤。

# 您需要为本书做些什么

本书中显示的所有实验都是在运行版本 16.04 和 Docker 引擎版本 1.12 的 Ubuntu Linux 主机上执行的。

### 注意

您会注意到，本书中主机上使用的网络接口名称使用熟悉的 eth（eth0、eth1 等）命名约定。虽然这在许多 Linux 版本上仍然是标准，但运行 systemd 的新版本（如 Ubuntu 16.04）现在使用称为可预测网络接口名称（PNIN）的东西。使用 PNIN 时，网络接口使用基于接口本身信息的更可预测的名称。在这些情况下，接口名称将以不同的名称显示，例如 ens1 或 ens32。为了使本书中的内容更容易理解，我选择在所有主机上禁用了 PNIN。如果您有兴趣执行相同的操作，可以通过网络搜索“Ubuntu 禁用可预测接口名称”找到说明。如果您选择不这样做，只需知道您的接口名称将显示为与我的示例不同的方式。

本书中显示的实验室要求包括在每个配方的开头。后续的配方可能会基于早期配方中显示的配置。

# 这本书是为谁准备的

本书适用于那些对了解 Docker 如何实现容器网络感兴趣的人。虽然这些配方涵盖了许多基础知识，但假定您具有对 Linux 和 Docker 的工作知识，并且具有对网络的基本理解。

# 约定

在本书中，您会发现许多文本样式，用于区分不同类型的信息。以下是一些这些样式的例子以及它们的含义解释。

文本中的代码词、文件路径和可执行文件显示如下：

“可以使用`ip link show`命令在主机上查看接口”。

任何命令行输入或输出都将按如下方式编写：

```
user@net1:~$ sudo ifdown eth1 && sudo ifup eth1
```

在可能的情况下，任何多行命令行输入将使用 Linux 行继续方法编写，即在要继续的行的末尾包括一个尾随的`\`：

```
user@net1:~$ sudo ip netns exec ns_1 ip link set \
dev edge_veth1 master edge_bridge1
```

在某些情况下，命令行输出也可能是多行的。在这种情况下，格式化是为了使输出易于阅读。

当我们希望引起您对命令行输出的特别关注时，相关行或项目将以粗体显示：

```
user@net2:~$ ip addr show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:59:ca:ca brd ff:ff:ff:ff:ff:ff
    inet **172.16.10.2/26** brd 172.16.10.63 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe59:caca/64 scope link
       valid_lft forever preferred_lft forever
user@net2:~$

```

### 注意

警告或重要说明显示在这样的框中。
