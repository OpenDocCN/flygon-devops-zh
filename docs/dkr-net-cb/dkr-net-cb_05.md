# 第五章：容器链接和 Docker DNS

在本章中，我们将涵盖以下内容：

+   验证容器内的基于主机的 DNS 配置

+   覆盖默认名称解析设置

+   配置名称和服务解析的链接

+   利用 Docker DNS

+   创建 Docker DNS 别名

# 介绍

在前几章中，我已经指出 Docker 在网络空间为您做了很多事情。正如我们已经看到的，通过 IPAM 管理 IP 分配是使用 Docker 时并不明显的巨大好处。Docker 为您提供的另一项服务是 DNS 解析。正如我们将在本章中看到的，Docker 可以提供多个级别的名称和服务解析。随着 Docker 的成熟，提供这些类型的服务的选项也在不断增加。在本章中，我们将开始审查基本的名称解析以及容器如何知道使用哪个 DNS 服务器。然后，我们将涵盖容器链接，并了解 Docker 如何告诉容器有关其他容器和它们托管的服务。最后，我们将介绍随着用户定义网络的增加而带来的一些 DNS 增强功能。

# 验证容器内的基于主机的 DNS 配置

您可能没有意识到，但默认情况下，Docker 为您的容器提供了基本的名称解析手段。Docker 将名称解析选项从 Docker 主机直接传递到容器中。结果是，生成的容器可以本地解析 Docker 主机本身可以解析的任何内容。Docker 用于在容器中实现名称解析的机制非常简单。在本教程中，我们将介绍如何完成这项工作以及如何验证它是否按预期工作。

## 准备就绪

在本教程中，我们将演示单个 Docker 主机上的配置。假设该主机已安装 Docker，并且 Docker 处于默认配置状态。我们将在主机上更改名称解析设置，因此您需要 root 级别的访问权限。

## 操作步骤：

让我们在我们的主机`docker1`上启动一个新的容器，并检查容器如何处理名称解析：

[PRE0]

看起来容器有能力解析 DNS 名称。如果我们查看我们的本地 Docker 主机并运行相同的测试，我们应该会得到类似的结果：

[PRE1]

此外，就像我们的 Docker 主机一样，容器也可以解析与本地域`lab.lab`相关的本地 DNS 记录：

[PRE2]

您会注意到，我不需要指定一个完全合格的域名来解析域`lab.lab`中的主机名`docker4`。此时，可以安全地假设容器正在从 Docker 主机接收某种智能更新，为其提供有关本地 DNS 配置的相关信息。

### 注意

请注意，`resolv.conf`文件通常是您定义 Linux 系统名称解析参数的地方。在许多情况下，它会被其他地方的配置信息自动更改。但是，无论如何更改，它都应该始终是系统处理名称解析的真相来源。

要查看容器正在接收的内容，让我们检查容器的`resolv.conf`文件：

[PRE3]

正如您所看到的，容器已经学会了本地 DNS 服务器是`10.20.30.13`，本地 DNS 搜索域是`lab.lab`。它是从哪里获取这些信息的？答案相当简单。当容器启动时，Docker 为每个生成的容器实例生成以下三个文件的实例，并将其保存在容器配置中：

+   `/etc/hostname`

+   `/etc/hosts`

+   `/etc/resolv.conf`

这些文件作为容器配置的一部分存储，然后挂载到容器中。我们可以使用容器内的`findmnt`工具来检查挂载的来源：

[PRE4]

因此，虽然容器认为它在其`/etc/`目录中有`hostname`、`hosts`和`resolv.conf`文件的本地副本，但实际文件实际上位于 Docker 主机上的容器配置目录(`/var/lib/docker/containers/`)中。

当您告诉 Docker 运行一个容器时，它会执行以下三件事：

+   它检查 Docker 主机的`/etc/resolv.conf`文件，并将其副本放在容器目录中

+   它在容器的目录中创建一个`hostname`文件，并为容器分配一个唯一的`hostname`

+   它在容器的目录中创建一个`hosts`文件，并添加相关记录，包括 localhost 和引用主机本身的记录

每次容器重新启动时，容器的`resolv.conf`文件都会根据 Docker 主机`resolv.conf`文件中找到的值进行更新。这意味着每次容器重新启动时，对`resolv.conf`文件所做的任何更改都会丢失。`hostname`和`hosts`配置文件也会在每次容器重新启动时被重写，丢失在上一次运行期间所做的任何更改。

为了验证给定容器正在使用的配置文件，我们可以检查这些变量的容器配置：

[PRE5]

正如预期的那样，这些是我们在容器内部运行`findmnt`命令时看到的相同挂载路径。这些代表了每个文件的确切挂载路径到容器的`/etc/`目录中的每个相应文件。

# 覆盖默认的名称解析设置

Docker 用于为容器提供名称解析的方法在大多数情况下都运行良好。然而，可能会有一些情况，您希望 Docker 为容器提供与 Docker 主机配置的 DNS 服务器不同的 DNS 服务器。在这些情况下，Docker 为您提供了一些选项。您可以告诉 Docker 服务为所有服务生成的容器提供不同的 DNS 服务器。您还可以通过在`docker run`子命令中提供 DNS 服务器作为选项，手动覆盖此设置。在本教程中，我们将向您展示更改默认名称解析行为的选项以及如何验证设置是否有效。

## 准备工作

在本教程中，我们将演示单个 Docker 主机上的配置。假设这个主机已经安装了 Docker，并且 Docker 处于默认配置。我们将在主机上更改名称解析设置，因此您需要 root 级别的访问权限。

## 操作步骤

正如我们在本章的第一个教程中看到的，默认情况下，Docker 为容器提供 Docker 主机本身使用的 DNS 服务器。这是通过复制主机的`resolv.conf`文件并提供给每个生成的容器。除了名称服务器设置，该文件还包括 DNS 搜索域的定义。这两个选项都可以在服务级别进行配置，以覆盖任何生成的容器，也可以在个体级别进行配置。

为了进行比较，让我们首先检查 Docker 主机的 DNS 配置：

[PRE6]

通过这个配置，我们期望在这个主机上生成的任何容器都会收到相同的名称服务器和 DNS 搜索域。让我们生成一个名为`web8`的容器，以验证这是否按预期工作：

[PRE7]

正如预期的那样，容器接收相同的配置。现在让我们检查容器，看看是否有任何与 DNS 相关的选项被定义：

[PRE8]

因为我们使用默认配置，所以在容器内部针对 DNS 服务器或搜索域没有必要配置任何特定的内容。每次容器启动时，Docker 都会将主机的`resolv.conf`文件的设置应用到容器的 DNS 配置文件中。

如果我们希望 Docker 为容器提供不同的 DNS 服务器或 DNS 搜索域，我们可以通过 Docker 选项来实现。在这种情况下，我们感兴趣的两个选项是：

+   `--dns=<DNS 服务器>`：指定 Docker 应该为容器提供的 DNS 服务器地址

+   `--dns-search=<DNS 搜索域>`：指定 Docker 应该为容器提供的 DNS 搜索域

让我们配置 Docker 以为容器提供一个公共 DNS 服务器（`4.2.2.2`）和一个搜索域`lab.external`。我们可以通过将以下选项传递给 Docker systemd drop-in 文件来实现：

[PRE9]

一旦配置了选项，重新加载 systemd 配置，重新启动服务以加载新选项，并重新启动我们的容器`web8`：

[PRE10]

您会注意到，尽管此容器最初具有主机的 DNS 服务器（`10.20.30.13`）和搜索域（`lab.lab`），但现在它具有我们刚刚指定的服务级 DNS 选项。如果您回想一下之前，我们看到，当我们检查这个容器时，它没有定义特定的 DNS 服务器或搜索域。由于没有指定，Docker 现在使用优先级较高的 Docker 选项的设置。尽管这提供了一定程度的灵活性，但它还不够灵活。在这一点上，此服务器上生成的任何和所有容器都将提供相同的 DNS 服务器和搜索域。为了真正灵活，我们应该能够让 Docker 在每个容器级别上改变名称解析配置。幸运的是，这些选项也可以直接在容器运行时提供。

![如何做…](img/B05453_05_01.jpg)

前面的图表定义了 Docker 在启动容器时决定应用哪些名称解析设置时使用的优先级。正如我们在前几章中看到的那样，容器运行时定义的设置始终优先。如果那里没有定义设置，Docker 然后会查看它们是否在服务级别上配置。如果那里没有设置，它将退回到依赖 Docker 主机的 DNS 设置的默认方法。

例如，我们可以启动一个名为`web2`的容器并提供不同的选项：

[PRE11]

如果我们检查容器，我们会看到`dns`和`dns-search`字段现在作为容器配置的一部分被定义：

[PRE12]

这确保了如果容器重新启动，它仍将具有最初在第一次运行容器时提供的相同的 DNS 设置。让我们对 Docker 服务进行一些微小的更改，以验证优先级是否按预期工作。让我们将我们的 Docker 选项更改为如下所示：

[PRE13]

现在重新启动服务并运行以下容器：

[PRE14]

因为我们在容器运行时没有提供任何与 DNS 相关的选项，所以我们需要检查的下一个地方将是服务级选项。我们的 Docker 服务级选项包括一个 DNS 搜索域`lab.external`。我们期望容器会收到该搜索域。然而，由于我们没有定义 DNS 服务器，我们需要回退到 Docker 主机本身上配置的 DNS 服务器。

现在检查它的`resolv.conf`文件，确保一切按预期工作：

[PRE15]

# 为名称和服务解析配置链接

容器链接提供了一种容器之间在同一主机上轻松通信的方式。正如我们在之前的例子中看到的，大多数容器之间的通信是通过 IP 地址进行的。容器链接通过允许链接的容器通过名称进行通信来改进了这一点。除了提供基本的名称解析外，它还提供了一种查看链接容器提供的服务的方法。在本教程中，我们将回顾如何创建容器链接，并讨论它们的一些局限性。

## 准备工作

在本教程中，我们将演示在单个 Docker 主机上的配置。假设该主机已安装 Docker，并且 Docker 处于默认配置。我们将在主机上更改名称解析设置，因此您需要 root 级别的访问权限。

## 如何做…

短语“容器链接”可能暗示着涉及某种网络配置或修改。实际上，容器链接与容器网络几乎没有关系。在默认模式下，容器链接提供了一种容器解析另一个容器名称的方法。例如，让我们在我们的实验主机`docker1`上启动两个容器：

[PRE16]

请注意，当我启动第二个容器时，我使用了一个名为 `--link` 的新标志，并引用了容器 `web1`。我们现在会说 `web2` 现在链接到 `web1`。但是，它们实际上并没有以任何方式链接。更好的描述可能是说 `web2` 现在知道了 `web1`。让我们连接到容器 `web2`，以便向您展示我的意思：

[PRE17]

看起来 `web2` 容器现在能够通过名称解析容器 `web1`。这是因为链接过程将记录插入到 `web2` 容器的 `hosts` 文件中：

[PRE18]

有了这个配置，`web2` 容器可以通过我们在运行时给容器的名称 (`web1`) 或 Docker 为容器生成的唯一 `hostname` 来到达 `web1` 容器 (`88f9c8629668`)。

除了更新 `hosts` 文件之外，`web2` 还生成了一些新的环境变量：

[PRE19]

您会注意到许多新的环境变量。Docker 将复制来自链接容器的任何环境变量，这些环境变量是作为容器的一部分定义的。这包括：

+   Docker 镜像中描述的环境变量。更具体地说，来自镜像 Dockerfile 的任何 `ENV` 变量

+   通过 `--env` 或 `-e` 标志在运行时传递给容器的环境变量

在这种情况下，这三个变量在镜像的 Dockerfile 中被定义为 `ENV` 变量：

[PRE20]

因为两个容器镜像都定义了相同的 `ENV` 变量，我们将看到本地变量以及以 `WEB1_ENV_` 为前缀的来自容器 `web1` 的相同环境变量：

[PRE21]

此外，Docker 还创建了描述 `web1` 容器以及其任何暴露端口的其他六个环境变量：

[PRE22]

链接还允许您指定别名。例如，让我们使用稍微不同的链接语法停止、删除和重新生成容器 `web2`：

[PRE23]

请注意，在链接定义之后，我们插入了 `a :webserver.` 冒号后面的名称表示链接的别名。在这种情况下，我指定了容器 `web1` 的别名为 `webserver`。

如果我们检查 `web2` 容器，我们会看到别名现在也列在 `hosts` 文件中：

[PRE24]

别名还会影响链接期间创建的环境变量。它们不会使用容器名称，而是使用别名：

[PRE25]

此时，您可能想知道这有多动态。毕竟，Docker 通过更新每个容器中的静态文件来提供这个功能。如果容器的 IP 地址发生变化会发生什么？例如，让我们停止容器`web1`，然后使用相同的镜像启动一个名为`web3`的新容器：

[PRE26]

如果您还记得之前，容器`web1`的 IP 地址是`172.17.0.2`。由于我停止了容器，Docker 将释放该 IP 地址的保留，使其可以重新分配给我们启动的下一个容器。让我们检查分配给容器`web3`的 IP 地址：

[PRE27]

正如预期的那样，`web3`获取了先前属于`web1`容器的现在开放的 IP 地址`172.17.0.2`。我们还可以验证容器`web2`仍然认为这个 IP 地址属于`web1`容器：

[PRE28]

如果我们再次启动容器`web1`，我们应该看到它将获得一个新的分配给它的 IP 地址：

[PRE29]

如果我们再次检查容器`web2`，我们应该看到 Docker 已经更新它以引用`web1`容器的新 IP 地址：

[PRE30]

然而，虽然 Docker 负责更新`hosts`文件中的新 IP 地址，但它不会负责更新任何环境变量以反映新的 IP 地址：

[PRE31]

此外，应该指出，这个链接只是单向的。也就是说，这个链接不会使容器`web1`意识到`web2`容器。`Web1`不会接收主机记录或引用`web2`容器的环境变量：

[PRE32]

另一个配置链接的原因是当您将 Docker **容器间连接**（**ICC**）模式设置为`false`时。正如我们之前讨论过的，ICC 阻止同一网桥上的任何容器直接交流。这迫使它们只能通过发布的端口进行交流。链接提供了一个机制来覆盖默认的 ICC 规则。为了演示，让我们停止并删除主机`docker1`上的所有容器，然后将以下 Docker 选项添加到 systemd drop-in 文件中：

[PRE33]

现在重新加载 systemd 配置，重新启动服务，并启动以下容器：

[PRE34]

在 ICC 模式下，您会注意到容器无法直接交流：

[PRE35]

在上面的例子中，`web2`无法访问`web1`上的 Web 服务器。现在，让我们删除并重新创建`web2`容器，这次将其链接到`web1`：

[PRE36]

我们可以看到，链接建立后，通信按预期允许。再次强调，就像链接一样，这种访问是单向允许的。

应该注意的是，在使用用户定义网络时，链接的工作方式不同。在本教程中，我们涵盖了现在被称为**传统链接**的内容。连接到用户定义网络将在接下来的两个教程中介绍。

# 利用 Docker DNS

用户定义网络的引入标志着 Docker 网络的重大变化。虽然提供自定义网络的能力是重大新闻，但名称解析也有了重大改进。用户定义网络可以受益于被称为**嵌入式 DNS**的功能。Docker 引擎本身现在具有为所有容器提供名称解析的能力。这是与传统解决方案相比的显著改进，传统解决方案中名称解析的唯一手段是外部 DNS 或依赖`hosts`文件的链接。在本教程中，我们将介绍如何使用和配置嵌入式 DNS。

## 准备工作

在本教程中，我们将演示在单个 Docker 主机上的配置。假设该主机已安装了 Docker，并且 Docker 处于默认配置状态。我们将在主机上更改名称解析设置，因此您需要 root 级别的访问权限。

## 操作步骤…

如前所述，嵌入式 DNS 系统仅在用户定义的 Docker 网络上运行。也就是说，让我们提供一个用户定义的网络，然后在其上启动一个简单的容器：

[PRE37]

正如我们在之前的教程中看到的，默认情况下，Docker 从 Docker 主机获取名称解析配置，并将其提供给容器。可以通过在服务级别或容器运行时提供不同的 DNS 服务器或搜索域来更改此行为。对于连接到用户定义网络的容器，提供给容器的 DNS 设置略有不同。例如，让我们看看刚刚连接到用户定义桥接`mybridge1`的容器的`resolv.conf`文件：

[PRE38]

注意这个容器的名称服务器现在是`127.0.0.11`。这个 IP 地址代表 Docker 的嵌入式 DNS 服务器，并将用于任何连接到用户定义网络的容器。任何连接到用户定义网络的容器都应该使用嵌入式 DNS 服务器。

最初未在用户定义的网络上启动的容器将在连接到用户定义的网络时进行更新。例如，让我们启动另一个名为`web2`的容器，但让它使用默认的`docker0`桥接：

[PRE39]

如果我们现在将`web2`容器连接到我们自定义的网络，Docker 将更新名称服务器以反映嵌入式 DNS 服务器：

[PRE40]

由于我们的两个容器现在都连接到同一个用户定义的网络，它们现在可以通过名称相互访问：

[PRE41]

您会注意到名称解析是双向的，并且它在没有任何链接的情况下固有地工作。也就是说，使用用户定义的网络，我们仍然可以定义链接，以便创建本地别名。例如，让我们停止并删除`web1`和`web2`两个容器，然后重新配置它们如下：

[PRE42]

要指出的第一件有趣的事情是，Docker 允许我们链接到尚不存在的容器。当我们运行容器`web1`时，我们要求 Docker 将其链接到容器`web2`。那时，`web2`并不存在。这是链接与嵌入式 DNS 服务器工作方式的一个显着差异。在传统的链接中，Docker 需要在进行链接之前知道目标容器的信息。这是因为它必须手动更新源容器的主机文件和环境变量。第二个有趣的事情是，别名不再列在容器的`hosts`文件中。如果我们查看每个容器的`hosts`文件，我们会发现链接不再生成条目：

[PRE43]

现在所有的解析都是在嵌入式 DNS 服务器中进行的。这包括跟踪定义的别名及其范围。因此，即使没有主机记录，每个容器也能够通过嵌入式 DNS 服务器解析其他容器的别名：

[PRE44]

创建的别名的范围仅限于容器本身。例如，同一用户定义的网络上的第三个容器无法解析链接的一部分创建的别名：

[PRE45]

您会记得，传统的链接还会自动在源容器上创建一组环境变量。这些环境变量引用了目标容器和它可能正在暴露的任何端口。在用户定义的网络中进行链接不会创建这些环境变量：

[PRE46]

正如我们在上一个示例中看到的，即使使用传统的链接，也无法保持这些变量的最新状态。也就是说，当处理用户定义的网络时，功能不存在并不是完全令人惊讶。

除了提供本地容器解析外，嵌入式 DNS 服务器还处理任何外部请求。正如我们在前面的示例中看到的，来自 Docker 主机（在我的情况下是`lab.lab`）的搜索域仍然被传递给容器，并在它们的`resolv.conf`文件中配置。从主机学习的名称服务器成为嵌入式 DNS 服务器的转发器。这允许嵌入式 DNS 服务器处理任何容器名称解析请求，并将外部请求移交给 Docker 主机使用的名称服务器。这种行为可以在服务级别或在运行时通过传递`--dns`或`--dns-search`标志来覆盖。例如，我们可以启动`web1`容器的另外两个实例，并在任何情况下指定特定的 DNS 服务器：

[PRE47]

### 注意

请注意，即使我们没有明确指定，`web4`也会接收`10.20.30.13`作为 DNS 转发器。这是因为这也是 Docker 主机使用的 DNS 服务器，当未指定时，容器会继承自主机。这里为了示例而指定。

现在，如果我们尝试在任何一个容器上解析本地 DNS 记录，我们可以看到，在`web1`的情况下它可以工作，因为它定义了本地 DNS 服务器，而在`web2`上的查找失败，因为`8.8.8.8`不知道`lab.lab`域：

[PRE48]

# 创建 Docker DNS 别名

在嵌入式 DNS 之前，将容器别名为不同名称的唯一方法是使用链接。正如我们在之前的示例中看到的，这仍然是用于创建本地化或特定于容器的别名的方法。但是，如果您想要具有更大范围的别名，任何连接到给定网络的容器都可以解析的别名呢？嵌入式 DNS 服务器提供了所谓的网络范围别名，这些别名可以在给定的用户定义网络中解析。在本示例中，我们将向您展示如何在用户定义的网络中创建网络范围的别名。

## 准备工作

在本示例中，我们将演示在单个 Docker 主机上的配置。假设该主机已安装 Docker，并且 Docker 处于默认配置状态。我们将更改主机上的名称解析设置，因此您需要 root 级别的访问权限。

## 如何做…

网络别名可以以几种不同的方式定义。它们可以在容器运行时定义，也可以在将容器连接到网络时定义。再次强调，网络别名是仅在容器实现用户定义网络时提供的功能。您不能在不同时指定用户定义网络的情况下创建网络别名。Docker 将阻止您在容器运行时指定它们：

[PRE49]

如果我们创建一个用户定义的网络并将其指定为容器配置的一部分，该命令将成功执行：

[PRE50]

一旦别名被创建，我们可以将其视为特定容器配置的一部分。例如，如果我们现在检查容器`web1`，我们将在其网络配置下看到一个定义的别名：

[PRE51]

现在，让我们启动另一个名为`web2`的容器，并看看我们是否可以解析别名：

[PRE52]

这里有几件有趣的事情要指出。首先，定义别名的方法与链接方法有很大不同，不仅仅是范围。通过链接，源容器指定了它希望将目标容器别名为的内容。在网络别名的情况下，源容器设置了自己的别名。

其次，这只能工作是因为容器`web2`在与`web1`相同的用户定义网络上。因为别名的范围是整个用户定义的网络，这意味着同一个容器在不同的用户定义网络上可以使用不同的别名。例如，让我们创建另一个用户定义的网络：

[PRE53]

现在，让我们将容器`web1`连接到它：

[PRE54]

回想一下，我们说过您可以在`network connect`子命令的一部分中定义网络范围的别名：

[PRE55]

请注意，容器`web1`现在有两个别名，一个在每个网络上。因为容器`web2`只连接到一个网络，所以它仍然只能解析与`mybridge1`网络关联的别名：

[PRE56]

然而，一旦我们将`web2`连接到`mybridge2`网络，它现在可以解析两个别名：

[PRE57]

有趣的是，Docker 还允许您将相同的别名定义为多个容器。例如，现在让我们启动一个名为`web3`的第三个容器，并使用与`web1`（`webserver1`）相同的别名将其连接到`mybridge1`：

[PRE58]

别名现在已经为容器`web1`和`web2`定义。但是，尝试从`web2`解析别名仍然指向`web1`：

[PRE59]

如果我们断开或停止容器`web1`，我们应该会看到分辨率现在改变为`web3`，因为它仍然在网络上活动，并且具有相同的别名：

[PRE60]

这个功能可以为您提供一些有趣的选择，特别是在与叠加网络类型配合使用时，可以实现高可用性或故障转移。

值得注意的是，这个功能适用于所有用户定义的网络类型，包括叠加网络类型。我们在这些示例中使用桥接来保持示例简单。
