# 第十六章：评估

# 第一章 - 与 Kubernetes 通信

1.  容器编排是一种软件模式，其中多个容器被控制和调度以便为应用程序提供服务。

1.  Kubernetes API 服务器（`kube-apiserver`）处理更新 Kubernetes 资源的请求。调度程序（`kube-scheduler`）决定在哪里放置（调度）容器。控制器管理器（`kube-controller-manager`）确保 Kubernetes 资源的期望配置反映在集群中。`etcd`为集群配置提供数据存储。

1.  `kube-apiserver`必须使用`--authorization-mode=ABAC`和`--authorization-policy-file=filename`参数启动。

1.  为了保证控制平面的高可用性，以防其中一个主节点发生故障。

1.  如果资源已经创建，`kubectl create`将失败，因为资源已经存在，而`kubectl apply`将尝试将任何 YAML 更改应用于资源。

1.  `kubectl use-context`命令可用于在`kubeconfig`文件中切换多个上下文。要在`kubeconfig`文件之间切换，可以将`KUBECONFIG`环境变量设置为新文件的路径。

1.  命令式命令不提供对资源更改的历史记录。

# 第二章 - 设置您的 Kubernetes 集群

1.  Minikube 使得在本地轻松设置 Kubernetes 集群进行开发。

1.  在某些情况下，集群的固定最低成本可能大于自行配置的集群。一些托管选项还有许可成本，除了计算成本之外。

1.  Kubeadm 对基础设施提供商是不可知的，而 Kops 仅支持几个主要提供商，并具有更深入的集成和计算资源提供。

1.  截至本书撰写时，AWS，Google Cloud Platform，Digital Ocean，VMware 和 OpenStack 在各种生产准备级别上。

1.  通常，集群组件在`systemd`服务定义中定义，这允许在节点在操作系统级别关闭和重新启动时自动重新启动服务。

# 第三章 - 在 Kubernetes 上运行应用程序容器

1.  如果您有开发、分级和生产环境，您可以为每个环境创建一个命名空间。

1.  Pod 正在运行的节点可能处于*损坏*状态，控制平面无法到达它。通常，当节点正常退出集群时，Pod 将被简单地重新调度，而不是显示*未知*状态。

1.  防止占用内存的 Pod 占据整个节点并导致节点上其他 Pod 的不确定行为。

1.  如果有*Startup*探测器，您应该增加更多的延迟。如果没有，您将需要添加一个，或者在*Readiness*探测器中添加延迟。

# 第四章 - 扩展和部署您的应用程序

1.  ReplicationControllers 在选择器配置方面的灵活性较小 - 只允许键值选择器。

1.  部署允许您指定如何滚动更新。

1.  作业非常适合批处理任务，或者可以水平扩展并具有明确完成目标的任务。

1.  StatefulSets 提供了一个有序的 Pod 标识，当这些 Pod 重新启动时保持不变。

1.  除了现有版本外，还可以创建一个带有金丝雀版本的新部署。然后，两个版本可以并行访问。

# 第五章 - 服务和入口 - 与外部世界通信

1.  您应该使用 ClusterIP 服务。

1.  您可以使用`kubectl describe`命令查看 NodePort 服务在节点上的哪个端口处于活动状态。

1.  在云环境中，您经常需要按负载均衡器付费，入口允许您指定多个路由规则，同时只需支付一个负载均衡器的费用。

1.  ExternalName 服务可用于轻松路由到云环境中的其他基础设施 - 例如托管数据库和对象存储。

# 第六章 - Kubernetes 应用程序配置

1.  秘密以编码形式存储，并在`etcd`中可选加密。ConfigMaps 以明文形式存储。

1.  它们是 Base64 编码的。

1.  在描述 ConfigMap 时，数据将更加可见。当将 ConfigMap 挂载为环境变量时，键值模式也更容易使用。

1.  根据您设置集群的方式，您的秘密可能根本没有加密。如果集群的 EncryptionConfiguration 未设置，秘密将只被 Base64 编码 - 并且可以很容易地被解码。通过使用 EncryptionConfiguration 创建您的集群，您的秘密将以加密形式存储在`etcd`中。这并不是一个安全的灵丹妙药，但是静态加密对于提高秘密的安全性当然是必要的。

# 第七章 - Kubernetes 上的存储

1.  卷与 Pod 的生命周期相关联，并在删除 Pod 时被删除。持久卷将保留，直到集群被删除，或者它们被明确地删除。

1.  StorageClasses 定义持久卷的*类型*。它们可用于区分不同类型的存储，例如更快的 SSD 存储和较慢的硬盘存储 - 或不同类型的云存储。StorageClasses 确定持久卷索赔和持久卷将去获取配置存储的位置。

1.  使用带有集成存储配置的托管 Kubernetes 服务，或者向您的集群添加**cloud-controller-manager**配置。

1.  任何需要存储状态超过单个 Pod 寿命的应用程序都无法使用卷。任何需要具有对 Pod 故障具有容忍性状态的应用程序都需要持久卷。

# 第八章 - Pod 放置控制

1.  节点选择器可用于匹配节点标签，并且多个节点可以满足要求。使用节点名称意味着您指定必须放置 Pod 的单个节点。

1.  Kubernetes 实施了一些默认的污点，以确保 Pod 不会被调度到发生故障或缺乏资源的节点上。此外，Kubernetes 会在主节点上设置污点，以防止用户应用程序在主节点上进行调度。

1.  太多的亲和性和反亲和性可能会减慢调度器的速度，或导致其无响应。在具有许多亲和性或反亲和性的情况下确定 Pod 的放置是非常计算密集的。

1.  使用反亲和性，您可以防止 Pod 与同一故障域中的相似 Pod 共存。同一故障域中的节点将带有故障域或区域标识符。反亲和性将寻找与同一故障域中应用程序级别的特定层相匹配的 Pod，并防止在匹配该域的节点上进行调度。最终结果将是三层应用程序的每个层在多个故障域中分布。

# 第九章 - Kubernetes 上的可观察性

1.  指标对应于数字值，表示应用程序/计算性能和/或跨许多类别的使用情况，包括磁盘、CPU、内存、延迟等。日志对应于应用程序、节点或控制平面文本日志。

1.  Grafana UI 高度可定制，并可用于以优雅灵活的方式呈现复杂的 Prometheus（或其他数据源的）查询。

1.  FluentD 需要在生产集群上运行以收集日志。Elasticsearch 和 Kibana 可以在单独的集群或其他基础设施上运行。

# 第十章 - Kubernetes 故障排除

1.  Kubernetes 的一个优势是通过添加节点或使用控件（如污点和容忍度）轻松扩展集群。 此外，Pod 重新启动可能导致相同应用程序具有完全不同的 IP。 这意味着计算和网络拓扑结构可能会不断变化。

1.  `kubelet`通常作为 Linux 服务在`systemd`中运行，可以使用`systemctl`进行控制，并在`journalctl`中查看日志。

1.  有一些不同的方法可以使用，但通常，您会想要检查所有节点是否准备就绪和可调度； 是否有任何 Pod 放置控件阻止了 Pod 的调度； 以及是否存在任何依赖存储、ConfigMaps 或不存在的 secrets。

# 第十一章 - 模板代码生成和 Kubernetes 上的 CI/CD

1.  Helm Charts 使用模板和变量，而 Kustomize 使用基于补丁的策略。 Kustomize 内置于最新版本的 kubectl 中，而 Helm 使用单独的 CLI 工具。

1.  配置应强调安全性，因为部署凭据可能被用于部署攻击者的工作负载到您的集群。 在云提供商上使用安全环境变量或访问管理控制是两种好策略。 凭据绝对不应放置在任何 Git 存储库中。

1.  在集群内设置可能更可取，因为 Kubernetes 凭据不需要由外部系统提供。 集群外设置通常比集群内设置更简单，更同步，其中控制循环确定何时对资源配置进行更改。

# 第十二章 - Kubernetes 安全性和合规性

1.  MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。

1.  具有空 Pod 选择器的 NetworkPolicy 会选择所有 Pod。 具有选择了所有 Pod 的 NetworkPolicy，并且添加了 Ingress 和 Egress 类型而没有任何规则，将自动拒绝对命名空间中所有 Pod 的所有入口和出口。

1.  我们希望跟踪任何 API 请求，在这些请求中资源被打补丁或更新，因为攻击者可能会更新部署、Pod 或其他资源，并植入恶意容器。

# 第十三章 - 使用 CRD 扩展 Kubernetes

1.  存储版本是实际存储在数据存储中的版本。 服务版本是 API 接受的任何读取或写入操作的版本。 存储在`etcd`中时，服务版本将转换为存储版本。

1.  测量、分析和更新（通常）。

1.  根据云提供商，**cluster-autoscaler**插件将直接更新自动缩放组，以添加或删除节点。

# 第十四章 - 服务网格和无服务器

1.  静态的 Envoy 配置是指由用户手动创建或编写的 Envoy 配置。动态的 Envoy 配置（例如 Istio 提供的那些）将不断适应新的容器，以及来自外部控制器或数据平面的新路由和过滤规则。

1.  监听器、路由、集群和端点。

1.  Knative 需要许多组件才能运行。这样可以进行大量定制，但使得设置和操作比 OpenFaaS 更困难。

# 第十五章 - Kubernetes 上的有状态工作负载

1.  Minio 是一种与 AWS S3 兼容的存储工具。

1.  StatefulSets 通过提供稳定的序数 Pod 标识以及持久卷稳定性，帮助自我集群化的应用程序，如分布式数据库。

1.  在 Kubernetes 中，Pod 可以是短暂的，有状态的应用程序可以是分布式的。这意味着在 Pod 之间保持状态的过程（例如，数据库一致性）可能会变得困难，如果 Pod 改变身份并且需要从头开始复制存储。
