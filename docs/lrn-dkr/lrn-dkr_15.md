# 编排器

在上一章中，我们介绍了 Docker Compose，这是一个允许我们在单个 Docker 主机上以声明方式定义多服务应用程序的工具。

本章介绍了编排器的概念。它教会我们为什么需要编排器，以及它们在概念上是如何工作的。本章还将概述最流行的编排器，并列出它们的一些优缺点。

在本章中，我们将涵盖以下主题：

+   编排器是什么，为什么我们需要它们？

+   编排器的任务

+   流行编排器概述

完成本章后，您将能够做到以下几点：

+   列举编排器负责的三到四个任务

+   列举两到三个最流行的编排器

+   用你自己的话和适当的类比向一个感兴趣的外行解释为什么我们需要容器编排器

# 编排器是什么，为什么我们需要它们？

在[第九章]（bbbf480e-3d5a-4ad7-94e9-fae735b025ae.xhtml）*，分布式应用架构*中，我们了解了成功构建、部署和运行高度分布式应用程序常用的模式和最佳实践。现在，如果我们的分布式应用程序是容器化的，那么我们将面临与非容器化分布式应用程序面临的完全相同的问题或挑战。其中一些挑战是在[第九章]（bbbf480e-3d5a-4ad7-94e9-fae735b025ae.xhtml）*，分布式应用架构*中讨论过的——服务发现、负载均衡、扩展等等。

类似于 Docker 对容器所做的事情——通过引入这些容器来标准化软件的打包和交付——我们希望有一些工具或基础设施软件来处理提到的所有或大部分挑战。这个软件就是我们所说的容器编排器，或者我们也称之为编排引擎。

如果我刚才说的对你来说还不太有意义，那么让我们从另一个角度来看。拿一个演奏乐器的艺术家来说。他们可以独自为观众演奏美妙的音乐 - 只有艺术家和他们的乐器。但现在想象一个由音乐家组成的管弦乐团。把他们都放在一个房间里，给他们一首交响乐的音符，让他们演奏，并离开房间。没有指挥，这群非常有才华的音乐家将无法和谐地演奏这首曲子；它听起来或多或少会像一片杂音。只有管弦乐团有一个指挥，来指挥这群音乐家，管弦乐团的音乐才会让我们的耳朵愉悦：

*那么，我们期望一个值得投资的编排者为我们执行哪些任务呢？* 让我们详细看一下。以下列表显示了在撰写本文时，企业用户通常期望从他们的编排者那里得到的最重要的任务。

容器编排者就像管弦乐团的指挥

我希望你现在能更清楚地看到容器编排者是什么，以及为什么我们需要它。假设你确认了这个问题，我们现在可以问自己编排者将如何实现预期的结果，即确保集群中的所有容器和谐地相互配合。嗯，答案是，编排者必须执行非常具体的任务，类似于管弦乐团的指挥也有一系列任务要执行，以驯服和同时提升管弦乐团。

来源：https://it.wikipedia.org/wiki/Giuseppe_Lanzetta#/media/File:UMB_5945.JPGLicense: https://creativecommons.org/licenses/by-sa/3.0/deed.en

# 编排者的任务

现在我们有的不是音乐家，而是容器，不同的乐器，而是对容器主机运行的不同要求。音乐以不同的速度演奏，我们有以特定方式相互通信的容器，并且需要扩展和缩减。在这方面，容器编排者与管弦乐团的指挥有着非常相似的角色。它确保集群中的容器和其他资源和谐地相互配合。

# 协调所需的状态

在使用编排器时，您以声明方式告诉它如何运行特定的应用程序或应用程序服务。我们在《Docker Compose》的[第十一章]中学到了声明式与命令式的含义。描述我们想要运行的应用程序服务的声明方式包括诸如要使用哪个容器镜像、要运行多少个此服务的实例、要打开哪些端口等元素。我们称这些应用服务属性的声明为“期望状态”。

因此，当我们现在首次告诉编排器根据声明创建这样一个新的应用服务时，编排器会确保在集群中安排尽可能多的容器。如果容器镜像尚未在集群的目标节点上可用，调度程序会确保首先从镜像注册表中下载它们。接下来，容器将以所有设置启动，例如要附加到的网络或要公开的端口。编排器会尽其所能确保将集群与声明的状态完全匹配。

一旦我们的服务按要求启动并运行，也就是说，它以期望的状态运行，那么编排器会继续监视它。每当编排器发现服务的实际状态与期望状态之间存在差异时，它会再次尽力调解期望状态。

应用程序服务的实际状态与期望状态之间可能存在什么差异呢？比如说，服务的一个副本，也就是一个容器，由于某种原因崩溃了，编排器会发现实际状态与期望状态之间的差异在于副本的数量：缺少一个副本。编排器会立即将一个新实例调度到另一个集群节点，以替换崩溃的实例。另一个差异可能是应用程序服务的实例数量过多，如果服务已经缩减。在这种情况下，编排器将随机关闭所需数量的实例，以实现实际实例和期望实例数量之间的平衡。另一个差异可能是编排器发现应用程序服务的一个实例运行了错误（可能是旧）版本的底层容器映像。到现在为止，你应该明白了吧？

因此，我们不需要主动监视集群中运行的应用程序服务，并纠正与期望状态的任何偏差，而是将这一繁琐的任务委托给编排器。只要我们使用声明性而不是命令式的方式描述应用程序服务的期望状态，这种方法就非常有效。

# 复制和全局服务

在由编排器管理的集群中，我们可能想要运行两种完全不同类型的服务。它们是*复制*和*全局*服务。复制服务是指需要在特定数量的实例中运行的服务，比如说 10 个。而全局服务则是要求集群中每个工作节点上都运行一个实例的服务。我在这里使用了“工作节点”这个术语。在由编排器管理的集群中，通常有两种类型的节点，即*管理节点*和*工作节点*。管理节点通常由编排器专门用于管理集群，不运行任何其他工作负载。而工作节点则运行实际的应用程序。

因此，编排器确保对于全局服务，无论有多少个工作节点，它都在每个工作节点上运行一个实例。我们不需要关心实例的数量，只需要确保在每个节点上都保证运行服务的单个实例。

再次，我们可以完全依赖编排器来处理这个问题。在复制的服务中，我们总是能够找到确切所需数量的实例，而对于全局服务，我们可以确保在每个工作节点上始终运行服务的一个实例。编排器将尽其所能保证这种期望状态。

在 Kubernetes 中，全局服务也被称为**DaemonSet**。

# 服务发现

当我们以声明方式描述应用服务时，我们永远不应该告诉编排器服务的不同实例必须在哪些集群节点上运行。我们让编排器决定哪些节点最适合这项任务。

当然，从技术上讲，指示编排器使用非常确定性的放置规则是可能的，但这将是一种反模式，不建议在非常特殊的边缘情况之外使用。

因此，如果我们现在假设编排引擎完全自由地决定放置应用服务的各个实例的位置，而且实例可能会崩溃并由编排器重新安排到不同的节点，那么我们会意识到，我们无法追踪每个实例在任何给定时间运行在哪里是一项徒劳的任务。更好的是，我们甚至不应该尝试知道这一点，因为这并不重要。

好吧，你可能会说，但如果我有两个服务，A 和 B，服务 A 依赖于服务 B；*服务 A 的任何给定实例都应该知道在哪里可以找到服务 B 的实例吗？*

在这里，我必须大声明确地说——不，不应该。在高度分布式和可扩展的应用程序中，这种知识是不可取的。相反，我们应该依赖编排器为我们提供所需的信息，以便访问我们依赖的其他服务实例。这有点像在电话的旧时代，当我们不能直接打电话给朋友，而必须打电话给电话公司的中央办公室，那里的一些操作员会将我们路由到正确的目的地。在我们的情况下，编排器扮演操作员的角色，将来自服务 A 实例的请求路由到可用的服务 B 实例。整个过程被称为**服务发现**。

# 路由

到目前为止，我们已经了解到在分布式应用中，有许多相互作用的服务。当服务 A 与服务 B 交互时，它是通过数据包的交换来实现的。这些数据包需要以某种方式从服务 A 传输到服务 B。这个从源到目的地传输数据包的过程也被称为**路由**。作为应用的作者或操作者，我们期望编排器来接管这个路由任务。正如我们将在后面的章节中看到的，路由可以发生在不同的层面。就像在现实生活中一样。假设你在一家大公司的办公楼里工作。现在，你有一份需要转发给公司另一名员工的文件。内部邮件服务将从你的发件箱中取出文件，并将其送到同一建筑物内的邮局。如果目标人员在同一建筑物内工作，文件可以直接转发给该人员。另一方面，如果该人员在同一街区的另一栋建筑物内工作，文件将被转发到目标建筑物的邮局，然后通过内部邮件服务分发给接收者。第三，如果文件的目标是公司位于不同城市甚至不同国家的另一分支机构的员工，那么文件将被转发给 UPS 等外部邮政服务，后者将把它运送到目标地点，然后再次由内部邮件服务接管并将其送达收件人。

当在容器中运行的应用服务之间路由数据包时，类似的事情会发生。源容器和目标容器可以位于同一集群节点上，这对应于两名员工在同一建筑物内工作的情况。目标容器可以在不同的集群节点上运行，这对应于两名员工在同一街区的不同建筑物内工作的情况。最后，第三种情况是当数据包来自集群外部并且必须路由到集群内部运行的目标容器时。

编排器必须处理所有这些情况，以及更多。

# 负载均衡

在高可用的分布式应用中，所有组件都必须是冗余的。这意味着每个应用服务都必须以多个实例运行，以便如果一个实例失败，整个服务仍然可用。

为了确保一个服务的所有实例实际上都在工作，而不是闲置，您必须确保对服务的请求均匀分布到所有实例。这种在服务实例之间分配工作负载的过程称为负载均衡。存在各种算法来分配工作负载。通常，负载均衡器使用所谓的轮询算法，确保工作负载使用循环算法均匀分布到实例上。

再次，我们期望编排器处理从一个服务到另一个服务的负载均衡请求，或者从外部来源到内部服务的请求。

# 扩展

当在由编排器管理的集群中运行我们的容器化分布式应用程序时，我们还希望有一种简单的方式来处理预期或意外的工作负载增加。为了处理增加的工作负载，我们通常会安排正在经历增加负载的服务的额外实例。然后负载均衡器将自动配置为在更多可用的目标实例之间分发工作负载。

但在现实场景中，工作负载会随时间变化而变化。如果我们看一个像亚马逊这样的购物网站，它在晚上高峰时段可能会有很高的负载，当每个人都在家里网上购物；在特殊的日子，比如黑色星期五，它可能会经历极端的负载；而在早晨可能会经历很少的流量。因此，服务不仅需要能够扩展，还需要在工作负载减少时能够缩减。

我们还期望编排器在扩展时以有意义的方式分发服务的实例。将所有服务实例安排在同一集群节点上是不明智的，因为如果该节点宕机，整个服务就会宕机。编排器的调度程序负责容器的放置，还需要考虑不将所有实例放置在同一台计算机机架上，因为如果机架的电源供应失败，整个服务将受到影响。此外，关键服务的服务实例甚至应该分布在数据中心，以避免中断。所有这些决定，以及许多其他决定，都是编排器的责任。

在云中，通常使用“可用区”这个术语，而不是计算机机架。

# 自愈

如今，编排器非常复杂，可以为我们做很多事情来维护一个健康的系统。编排器监视集群中运行的所有容器，并自动用新实例替换崩溃或无响应的容器。编排器监视集群节点的健康状况，并在节点变得不健康或宕机时将其从调度循环中移除。原本位于这些节点上的工作负载会自动重新调度到其他可用节点上。

所有这些活动，编排器监视当前状态并自动修复损坏或协调期望状态，导致了所谓的**自愈**系统。在大多数情况下，我们不需要积极参与和修复损害。编排器会自动为我们完成这些工作。

然而，有一些情况编排器无法在没有我们帮助的情况下处理。想象一种情况，我们有一个运行在容器中的服务实例。容器正在运行，并且从外部看起来非常健康。但是，容器内部运行的应用程序处于不健康状态。应用程序没有崩溃，只是不能再像最初设计的那样工作了。编排器怎么可能在没有我们提示的情况下知道这一点呢？它不可能！处于不健康或无效状态对每个应用服务来说意味着完全不同。换句话说，健康状态是与服务相关的。只有服务的作者或其操作者知道在服务的上下文中健康意味着什么。

现在，编排器定义了应用服务可以与其通信的接口或探针。存在两种基本类型的探针：

+   服务可以告诉编排器它的健康状态

+   服务可以告诉编排器它已经准备好或者暂时不可用

服务如何确定前面提到的任一答案完全取决于服务本身。编排器只定义了它将如何询问，例如通过`HTTP GET`请求，或者它期望的答案类型，例如`OK`或`NOT OK`。

如果我们的服务实现了逻辑来回答前面提到的健康或可用性问题，那么我们就拥有了一个真正的自愈系统，因为编排器可以终止不健康的服务实例并用新的健康实例替换它们，还可以将暂时不可用的服务实例从负载均衡器的轮询中移除。

# 零停机部署

如今，很难再为需要更新的关键任务应用程序辩解完全停机。这不仅意味着错失机会，还可能导致公司声誉受损。使用该应用程序的客户不再愿意接受这样的不便，并会迅速离开。此外，我们的发布周期变得越来越短。在过去，我们每年可能会有一两次新版本发布，但如今，许多公司每周甚至每天多次更新他们的应用程序。

解决这个问题的方法是提出一个零停机应用程序更新策略。编排器需要能够逐批更新单个应用程序服务。这也被称为**滚动更新**。在任何给定时间，只有给定服务的总实例数中的一个或几个会被关闭，并被该服务的新版本替换。只有新实例是可操作的，并且不会产生任何意外错误或显示任何不当行为，才会更新下一批实例。这一过程重复进行，直到所有实例都被替换为它们的新版本。如果由于某种原因更新失败，那么我们期望编排器自动将更新的实例回滚到它们的先前版本。

其他可能的零停机部署包括蓝绿部署和金丝雀发布。在这两种情况下，服务的新版本与当前活动版本并行安装。但最初，新版本只能在内部访问。运营人员可以对新版本运行烟雾测试，当新版本似乎运行良好时，就可以在蓝绿部署的情况下，将路由器从当前蓝色版本切换到新的绿色版本。一段时间内，新的绿色版本的服务将受到密切监控，如果一切正常，旧的蓝色版本就可以被废弃。另一方面，如果新的绿色版本不如预期那样工作，那么只需将路由器设置回旧的蓝色版本，就可以实现完全回滚。

在金丝雀发布的情况下，路由器被配置为将整体流量的一小部分，比如 1%，引导到服务的新版本，而仍然有 99%的流量通过旧版本路由。新版本的行为受到密切监视，并与旧版本的行为进行比较。如果一切正常，那么通过新服务引导的流量百分比会略微增加。这个过程会重复，直到 100%的流量通过新服务路由。如果新服务运行一段时间并且一切正常，那么旧服务可以被停用。

大多数编排器至少支持开箱即用的滚动更新类型的零停机部署。蓝绿部署和金丝雀发布通常很容易实现。

# 亲和性和位置感知

有时，某些应用服务需要节点上专用硬件的可用性。例如，I/O 密集型服务需要具有附加高性能**固态硬盘**（**SSD**）的集群节点，或者用于机器学习等用途的某些服务需要**加速处理单元**（**APU**）。编排器允许我们为每个应用服务定义节点亲和性。然后，编排器将确保其调度程序仅在满足所需条件的集群节点上调度容器。

避免将亲和力定义为特定节点；这将引入单点故障，从而损害高可用性。始终将多个集群节点定义为应用服务的目标。

一些编排引擎还支持所谓的**位置感知**或**地理感知**。这意味着您可以要求编排器将服务的实例均匀分布在不同位置的一组位置上。例如，您可以定义一个`数据中心`标签，其可能的值为`西`、`中`和`东`，并将该标签应用于具有对应于各自节点所在地理区域的值的所有集群节点。然后，您指示编排器使用此标签来进行某个应用服务的地理感知。在这种情况下，如果您请求该服务的九个副本，那么编排器将确保将三个实例部署到每个数据中心的节点中——西、中和东。

地理意识甚至可以按层次定义；例如，您可以将数据中心作为最高级别的判别器，然后是可用区。

地理意识或位置意识用于减少由电源供应故障或数据中心故障导致的中断的概率。如果应用实例分布在节点、可用区甚至数据中心之间，那么一切同时崩溃的可能性极小。总会有一个地区是可用的。

# 安全

如今，IT 安全是一个非常热门的话题。网络战争达到了历史最高点。大多数知名公司都曾是黑客攻击的受害者，造成了非常昂贵的后果。每个首席信息官（CIO）或首席技术官（CTO）最糟糕的噩梦之一就是早上醒来听到自己的公司成为黑客攻击的受害者，并且敏感信息被窃取或泄露的消息。

为了对抗大多数安全威胁，我们需要建立一个安全的软件供应链，并在深度上强制执行安全防御。让我们来看看您可以从企业级编排器中期望的一些任务。

# 安全通信和加密节点身份

首先，我们希望确保由编排器管理的集群是安全的。只有受信任的节点才能加入集群。加入集群的每个节点都会获得一个加密的节点身份，并且节点之间的所有通信必须加密。为此，节点可以使用相互传输层安全（MTLS）。为了相互认证集群的节点，使用证书。这些证书会定期自动轮换，或者根据请求进行轮换，以保护系统以防证书泄露。

集群中发生的通信可以分为三种类型。您可以谈论通信平面-管理、控制和数据平面：

+   管理平面由集群管理器或主节点使用，例如，调度服务实例，执行健康检查，或创建和修改集群中的任何其他资源，如数据卷、密钥或网络。

+   控制平面用于在集群的所有节点之间交换重要的状态信息。例如，这种信息用于更新用于路由目的的集群上的本地 IP 表。

+   数据平面是实际应用服务相互通信和交换数据的地方。

通常，编排器主要关心保护管理和控制平面。保护数据平面留给用户，尽管编排器可能会促进这项任务。

# 安全网络和网络策略

在运行应用服务时，并非每个服务都需要与集群中的其他服务通信。因此，我们希望能够将服务相互隔离，并且只在绝对需要相互通信的情况下在相同的网络沙盒中运行这些服务。所有其他服务和来自集群外部的所有网络流量都不应该有可能访问被隔离的服务。

至少有两种网络沙盒化的方式。我们可以使用软件定义网络（SDN）来分组应用服务，或者我们可以使用一个扁平网络，并使用网络策略来控制谁有权访问特定服务或服务组。

# 基于角色的访问控制（RBAC）

编排器必须履行的最重要任务之一（除了安全性）是为集群及其资源提供基于角色的访问。RBAC 定义了系统的主体、用户或用户组，组织成团队等如何访问和操作系统。它确保未经授权的人员无法对系统造成任何伤害，也无法看到他们不应该知道或看到的系统中的任何可用资源。

典型的企业可能有开发、QA 和生产等用户组，每个组都可以有一个或多个用户与之关联。开发人员约翰·多伊是开发组的成员，因此可以访问专门为开发团队提供的资源，但他不能访问例如生产团队的资源，其中安·哈伯是成员。反过来，她也不能干扰开发团队的资源。

实施 RBAC 的一种方式是通过定义授权。授权是主体、角色和资源集合之间的关联。在这里，角色由对资源的一组访问权限组成。这些权限可以是创建、停止、删除、列出或查看容器；部署新的应用服务；列出集群节点或查看集群节点的详细信息；以及许多其他权限。

资源集合是集群中逻辑相关的资源的组合，例如应用服务、秘密、数据卷或容器。

# 秘密

在我们的日常生活中，我们有很多秘密。秘密是不应该公开知道的信息，比如你用来访问在线银行账户的用户名和密码组合，或者你手机或健身房储物柜的密码。

在编写软件时，我们经常也需要使用秘密。例如，我们需要一个证书来验证我们的应用服务与我们想要访问的外部服务进行身份验证，或者我们需要一个令牌来在访问其他 API 时验证和授权我们的服务。过去，为了方便起见，开发人员通常会将这些值硬编码，或者将它们以明文形式放在一些外部配置文件中。在那里，这些非常敏感的信息对广大观众都是可访问的，而实际上，他们本不应该有机会看到这些秘密。

幸运的是，这些天，编排器提供了所谓的秘密，以高度安全的方式处理这些敏感信息。秘密可以由授权或信任的人员创建。这些秘密的值然后被加密并存储在高可用的集群状态数据库中。由于这些秘密是加密的，所以它们现在在静态时是安全的。一旦一个被授权的应用服务请求一个秘密，该秘密只会被转发到实际运行该特定服务实例的集群节点，并且秘密值永远不会存储在节点上，而是挂载到容器中的`tmpfs`基于 RAM 的卷中。只有在相应的容器内，秘密值才以明文形式可用。

我们已经提到，秘密在静态时是安全的。一旦它们被服务、集群管理器或主节点请求，主节点会解密秘密并将其通过网络发送到目标节点。*那么，秘密在传输过程中安全吗？*嗯，我们之前了解到集群节点使用 MTLS 进行通信，因此即使秘密以明文传输，也仍然是安全的，因为数据包将被 MTLS 加密。因此，秘密在静态和传输过程中都是安全的。只有被授权使用秘密的服务才能访问这些秘密值。

# 内容信任

为了增加安全性，我们希望确保只有受信任的图像在我们的生产集群中运行。一些编排器允许我们配置集群，以便它只能运行经过签名的图像。内容信任和签署图像的目的在于确保图像的作者是我们所期望的人，即我们信任的开发人员，甚至更好的是我们信任的 CI 服务器。此外，通过内容信任，我们希望保证我们获取的图像是新鲜的，而不是旧的，可能存在漏洞的图像。最后，我们希望确保图像在传输过程中不会被恶意黑客篡改。后者通常被称为**中间人**（**MITM**）攻击。

通过在源头签署图像，并在目标处验证签名，我们可以保证我们想要运行的图像没有被篡改。

# 逆向正常运行时间

我想在安全性的背景下讨论的最后一点是逆向正常运行时间。*这是什么意思呢？*想象一下，你已经配置和保护了一个生产集群。在这个集群上，你正在运行公司的一些关键应用程序。现在，一个黑客设法在你的软件堆栈中找到了一个安全漏洞，并且已经获得了对你的集群节点的 root 访问权限。这本身已经够糟糕了，但更糟糕的是，这个黑客现在可以掩盖他们在这个节点上的存在，毕竟他们已经有了 root 访问权限，然后将其用作攻击你的集群中其他节点的基地。

在 Linux 或任何 Unix 类型的操作系统中，root 访问权限意味着你可以在这个系统上做任何事情。这是某人可以拥有的最高级别的访问权限。在 Windows 中，相当于这个角色的是管理员。

但是，*如果我们利用容器是短暂的，集群节点通常可以快速配置，通常在几分钟内完全自动化的情况下呢？*我们只需在一定的正常运行时间后关闭每个集群节点，比如说 1 天。编排器被指示排空节点，然后将其从集群中排除。一旦节点离开集群，它就会被拆除并被一个新配置的节点所取代。

这样，黑客就失去了他们的基地，问题也被消除了。尽管这个概念目前还没有广泛应用，但对我来说，这似乎是向增加安全性迈出的一大步，而且据我与在这个领域工作的工程师讨论，实施起来并不困难。

# 内省

到目前为止，我们已经讨论了许多由编排器负责的任务，它可以完全自主地执行。但是，人类操作员也需要能够查看和分析集群上当前运行的内容，以及个别应用程序的状态或健康状况。为了做到这一点，我们需要进行内省。编排器需要以易于消化和理解的方式呈现关键信息。

编排器应该从所有集群节点收集系统指标，并使其对操作员可访问。指标包括 CPU、内存和磁盘使用情况、网络带宽消耗等。这些信息应该以逐个节点的方式轻松获取，以及以汇总形式获取。

我们还希望编排器能够让我们访问由服务实例或容器产生的日志。此外，如果我们有正确的授权，编排器还应该为我们提供对每个容器的`exec`访问权限。有了对容器的`exec`访问权限，您就可以调试行为不端的容器。

在高度分布式的应用程序中，每个对应用程序的请求都要经过多个服务，直到完全处理，跟踪请求是一项非常重要的任务。理想情况下，编排器支持我们实施跟踪策略，或者给我们一些好的遵循指南。

最后，人类操作员在使用所有收集到的指标、日志和跟踪信息的图形表示时，可以最好地监视系统。在这里，我们谈论的是仪表板。每个体面的编排器都应该提供至少一些基本的仪表板，以图形方式表示最关键的系统参数。

然而，人类操作员并不是唯一关心内省的人。我们还需要能够将外部系统连接到编排器，以便消费这些信息。需要提供一个 API，通过该 API，外部系统可以访问集群状态、指标和日志等数据，并利用这些信息做出自动决策，例如创建警报或电话警报、发送电子邮件，或者在系统超过某些阈值时触发警报。

# 流行编排器的概述

在撰写本文时，有许多编排引擎在使用中，但有一些明显的赢家。第一名显然是由 Kubernetes 占据，它统治着。遥遥领先的第二名是 Docker 自己的 SwarmKit，其次是其他一些，如 Apache Mesos，AWS 弹性容器服务（ECS），或 Microsoft Azure 容器服务（ACS）。

# Kubernetes

Kubernetes 最初由 Google 设计，后来捐赠给了云原生计算基金会（CNCF）。Kubernetes 是模仿 Google 专有的 Borg 系统而设计的，该系统多年来一直在超大规模上运行容器。Kubernetes 是 Google 重新设计的尝试，完全重新开始并设计一个系统，其中包含了与 Borg 学到的所有教训。

与专有技术 Borg 相反，Kubernetes 在早期就开源了。这是 Google 的一个非常明智的选择，因为它吸引了大量来自公司外部的贡献者，仅仅在短短几年内，Kubernetes 周围的生态系统更加庞大。你可以说 Kubernetes 是容器编排领域社区的宠儿。没有其他编排器能够产生如此多的炒作，并吸引如此多愿意以有意义的方式为项目的成功做出贡献的人才，无论是作为贡献者还是早期采用者。

在这方面，Kubernetes 在容器编排领域对我来说非常像 Linux 在服务器操作系统领域所变成的。Linux 已经成为服务器操作系统的事实标准。所有相关公司，如微软、IBM、亚马逊、红帽，甚至 Docker，都已经接受了 Kubernetes。

有一件事是无法否认的：Kubernetes 从一开始就被设计用于大规模扩展。毕竟，它是以 Google Borg 为目标而设计的。

可以提出反对 Kubernetes 的一个负面方面是，至少在撰写本文时，它仍然很复杂，设置和管理起来。对于新手来说，这是一个重大障碍。第一步是艰难的，但一旦你使用这个编排器一段时间，一切就会变得清晰。整体设计经过深思熟虑，执行得非常好。

在 Kubernetes 的 1.10 版本中，与其他编排器（如 Docker Swarm）相比，最初的缺点大多已经消除。例如，安全性和保密性现在不仅仅是一个事后的考虑，而是系统的一个组成部分。

新功能以惊人的速度实施。新版本大约每 3 个月发布一次，更确切地说，大约每 100 天发布一次。大多数新功能都是需求驱动的，也就是说，使用 Kubernetes 来编排其关键任务应用程序的公司可以提出他们的需求。这使得 Kubernetes 适合企业使用。认为这个编排器只适用于初创企业而不适用于风险规避型企业是错误的。相反的情况是。*我基于什么来做出这个断言？*嗯，我的断言是有根据的，因为像微软、Docker 和红帽这样的公司，他们的客户大多是大型企业，已经完全接受了 Kubernetes，并为其提供企业级支持，如果它被用于并集成到他们的企业产品中。

Kubernetes 支持 Linux 和 Windows 容器。

# Docker Swarm

众所周知，Docker 推广和商品化了软件容器。Docker 并没有发明容器，但是标准化了它们，并使其广泛可用，其中包括提供免费镜像注册表—Docker Hub。最初，Docker 主要关注开发人员和开发生命周期。然而，开始使用和喜爱容器的公司很快也希望不仅在开发或测试新应用程序时使用它们，而且在生产中运行这些应用程序时也使用它们。

最初，Docker 在这个领域没有什么可提供的，所以其他公司跳进这个真空并为用户提供帮助。但是没过多久，Docker 意识到有一个对于一个简单而强大的编排器的巨大需求。Docker 的第一次尝试是一个名为经典 Swarm 的产品。它是一个独立的产品，使用户能够创建一个 Docker 主机集群，可以用于以高可用和自愈的方式运行和扩展其容器化应用程序。

然而，经典 Docker Swarm 的设置很困难。涉及许多复杂的手动步骤。客户喜欢这个产品，但在处理其复杂性时遇到了困难。因此，Docker 决定可以做得更好。它回到了起点，并提出了 SwarmKit。SwarmKit 在 2016 年的 DockerCon 大会上在西雅图推出，并成为最新版本的 Docker 引擎的一个重要组成部分。是的，你没听错；SwarmKit 是，直到今天仍然是 Docker 引擎的一个重要组成部分。因此，如果你安装了 Docker 主机，你自动就有了 SwarmKit。

SwarmKit 的设计理念是简单和安全。其口号是，几乎可以轻松地设置一个 Swarm，并且 Swarm 在开箱即用时必须具有高度安全性。Docker Swarm 的运行基于最低权限的假设。

在集群中的第一个节点上使用`docker swarm init`开始安装完整、高可用的 Docker Swarm，这个节点成为所谓的领导者，然后在所有其他节点上使用`docker swarm join <join-token>`。`join-token`是在初始化期间由领导者生成的。整个过程在具有多达 10 个节点的集群上不到 5 分钟。如果自动化，时间会更短。

正如我之前提到的，安全性是 Docker 设计和开发 SwarmKit 时的首要考虑因素。容器通过依赖 Linux 内核命名空间和 cgroups、Linux 系统调用白名单（seccomp）以及对 Linux 功能和 Linux 安全模块（LSM）的支持来提供安全性。现在，在此基础上，SwarmKit 还增加了 MTLS 和在静态和传输中加密的秘密。此外，Swarm 定义了所谓的容器网络模型（CNM），允许为在集群上运行的应用服务提供沙盒环境的 SDN。

Docker SwarmKit 支持 Linux 和 Windows 容器。

# Apache Mesos 和 Marathon

Apache Mesos 是一个开源项目，最初旨在使服务器或节点集群从外部看起来像一个单一的大服务器。Mesos 是一种使计算机集群管理变得简单的软件。Mesos 的用户不必关心单个服务器，只需假设他们拥有一个庞大的资源池，这对应于集群中所有节点的所有资源的总和。

从 IT 术语上讲，Mesos 已经相当古老，至少与其他编排器相比是这样。它首次公开亮相是在 2009 年，但当时当然并不是为了运行容器，因为当时甚至还没有 Docker。与 Docker 对容器的处理方式类似，Mesos 使用 Linux cgroups 来隔离 CPU、内存或磁盘 I/O 等资源，以便为单个应用程序或服务提供资源隔离。

Mesos 实际上是其他建立在其之上的有趣服务的基础基础设施。从容器的角度来看，Marathon 非常重要。Marathon 是一个运行在 Mesos 之上的容器编排器，能够扩展到数千个节点。

Marathon 支持多个容器运行时，如 Docker 或其自己的 Mesos 容器。它不仅支持无状态的应用服务，还支持有状态的应用服务，例如像 PostgreSQL 或 MongoDB 这样的数据库。与 Kubernetes 和 Docker SwarmKit 类似，它支持本章前面描述的许多功能，例如高可用性、健康检查、服务发现、负载均衡和位置感知等等。

尽管 Mesos 和在一定程度上 Marathon 是相当成熟的项目，但它们的影响范围相对有限。它似乎在大数据领域最受欢迎，即运行诸如 Spark 或 Hadoop 之类的数据处理服务。

# 亚马逊 ECS

如果您正在寻找一个简单的编排器，并且已经深度融入了 AWS 生态系统，那么亚马逊的 ECS 可能是您的正确选择。但是，有一点非常重要的限制需要指出：如果您选择了这个容器编排器，那么您就将自己锁定在 AWS 中。您将无法轻松地将在 ECS 上运行的应用程序迁移到另一个平台或云上。

亚马逊将其 ECS 服务宣传为一个高度可扩展、快速的容器管理服务，可以轻松在集群上运行、停止和管理 Docker 容器。除了运行容器，ECS 还可以直接访问容器内运行的应用服务的许多其他 AWS 服务。这种与许多热门 AWS 服务的紧密无缝集成，使 ECS 对于寻求在强大且高度可扩展的环境中轻松运行其容器化应用的用户非常具有吸引力。亚马逊还提供自己的私有镜像注册表。

使用 AWS ECS，您可以使用 Fargate 来完全管理底层基础设施，让您专注于部署容器化应用程序，而不必关心如何创建和管理节点集群。ECS 支持 Linux 和 Windows 容器。

总之，ECS 使用简单，高度可扩展，并与其他热门的 AWS 服务很好地集成在一起；但它不像 Kubernetes 或 Docker SwarmKit 那样强大，并且仅在 Amazon AWS 上可用。

# 微软 ACS

与我们对 ECS 所说的类似，我们也可以对微软的 ACS 提出同样的要求。如果您已经在 Azure 生态系统中投入了大量资金，那么 ACS 是一个有意义的容器编排服务。我应该说与我为 Amazon ECS 指出的相同：如果您选择 ACS，那么您就会将自己锁定在微软的产品中。将容器化应用程序从 ACS 移动到其他平台或云将不容易。

ACS 是微软的容器服务，支持多个编排器，如 Kubernetes、Docker Swarm 和 Mesos DC/OS。随着 Kubernetes 变得越来越受欢迎，微软的重点显然已经转移到了该编排器上。微软甚至重新将其服务命名为 Azure Kubernetes Service（AKS），以便将重点放在 Kubernetes 上。

AKS 为您管理在 Azure 中托管的 Kubernetes 或 Docker Swarm 或 DC/OS 环境，这样您就可以专注于要部署的应用程序，而不必关心配置基础设施。微软自己声称如下：

“AKS 使得快速轻松地部署和管理容器化应用程序成为可能，而无需容器编排专业知识。它还通过根据需求提供、升级和扩展资源来消除持续运营和维护的负担，而不会使您的应用程序下线。”

# 总结

本章阐明了为什么首先需要编排器，以及它们在概念上是如何工作的。它指出了在撰写时最突出的编排器，并讨论了各种编排器之间的主要共同点和区别。

下一章将介绍 Docker 的本地编排器 SwarmKit。它将详细阐述 SwarmKit 用于在集群（本地或云中）部署和运行分布式、有弹性、健壮和高可用应用所使用的所有概念和对象。

# 问题

回答以下问题以评估您的学习进度：

1.  我们为什么需要编排器？提供两到三个理由。

1.  列出编排器的三到四个典型职责。

1.  请至少列出两个容器编排器，以及它们背后的主要赞助商。

# 进一步阅读

以下链接提供了有关编排相关主题的更深入的见解：

+   Kubernetes-生产级编排：[`kubernetes.io/.`](https://kubernetes.io/)

+   Docker Swarm 模式概述：[`docs.docker.com/engine/swarm/.`](https://docs.docker.com/engine/swarm/)

+   Marathon，Mesos 和 DC/OS 的容器编排平台：[https://](https://mesosphere.github.io/marathon/)[mesosphere.github.io/marathon/](https://mesosphere.github.io/marathon/)

+   解释容器和编排：[`bit.ly/2DFoQgx.`](https://bit.ly/2npjrEl)
